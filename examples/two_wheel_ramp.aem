// AEM Example: Two-Wheel Speed Ramp (Scheduler-Friendly & Refactored)
//
// This program controls two motors, ramping their speed from 0% to 50%
// and then back down to 0, repeating forever.
//
// This version demonstrates a clean hardware abstraction where pin objects
// (`PwmChannel`, `GpioPin`) are instantiated in `main_setup` and composed
// into higher-level drivers (`L298N_Driver`).

use stdlib::drivers::motor::Motor;
use stdlib::drivers::l298n::L298N_Driver;
use stdlib::pwm::{self, PwmChannel};
use stdlib::gpio::{self, GpioPin, PinMode};
use stdlib::Clock;
use stdlib::math;

// 1. The `hardware` block now only defines constants for the physical layout.
hardware {
    const LEFT_MOTOR_SPEED_PIN: u8 = 9;
    const LEFT_MOTOR_DIR1_PIN: u8 = 2;
    const LEFT_MOTOR_DIR2_PIN: u8 = 3;

    const RIGHT_MOTOR_SPEED_PIN: u8 = 10;
    const RIGHT_MOTOR_DIR1_PIN: u8 = 4;
    const RIGHT_MOTOR_DIR2_PIN: u8 = 5;
}

// 2. Global driver instances (same as before).
let mut motor_left: L298N_Driver;
let mut motor_right: L298N_Driver;

// 3. Global state variables for the ramp state machine.
let mut ramp_step: i16 = 1;
let mut current_speed: i16 = 0;

// 4. The main setup function now handles all object instantiation.
fn main_setup() {
    // Create instances of the low-level pin drivers using constants from the hardware block.
    let left_speed_ch = pwm::PwmChannel(
        pin_num: LEFT_MOTOR_SPEED_PIN, 
        freq: 1000, 
        resolution: 11
    );
    let left_dir1_pin = gpio::GpioPin(pin_num: LEFT_MOTOR_DIR1_PIN, mode: PinMode::OUTPUT);
    let left_dir2_pin = gpio::GpioPin(pin_num: LEFT_MOTOR_DIR2_PIN, mode: PinMode::OUTPUT);

    let right_speed_ch = pwm::PwmChannel(
        pin_num: RIGHT_MOTOR_SPEED_PIN, 
        freq: 1000, 
        resolution: 11
    );
    let right_dir1_pin = gpio::GpioPin(pin_num: RIGHT_MOTOR_DIR1_PIN, mode: PinMode::OUTPUT);
    let right_dir2_pin = gpio::GpioPin(pin_num: RIGHT_MOTOR_DIR2_PIN, mode: PinMode::OUTPUT);

    // Instantiate the higher-level motor drivers by passing them the pin driver objects.
    motor_left = L298N_Driver(en: left_speed_ch, in1: left_dir1_pin, in2: left_dir2_pin);
    motor_right = L298N_Driver(en: right_speed_ch, in1: right_dir1_pin, in2: right_dir2_pin);
    
    // Configure and start the RampTask (same as before).
    RampTask.setInterval(10);
    RampTask.start();
}

// 5. The RampTask remains unchanged, operating on the abstract `Motor` interface.
task RampTask {
    const MAX_RAMP_SPEED: i16 = 1023; // 50% speed

    motor_left.set_speed(current_speed);
    motor_right.set_speed(current_speed);

    current_speed = current_speed + ramp_step;

    if (ramp_step > 0 && current_speed >= MAX_RAMP_SPEED) {
        ramp_step = -1;
    } else if (ramp_step < 0 && current_speed <= 0) {
        ramp_step = 1;
    }
}