// AEM Example: Two-Wheel Speed Ramp (Scheduler-Friendly)
//
// This program controls two motors, ramping their speed from 0% to 50%
// and then back down to 0, repeating forever.
//
// This version is "non-blocking" and uses a state machine, which is a more
// scalable and efficient way to write code for a cooperative scheduler.

use stdlib::drivers::motor::Motor;
use stdlib::drivers::l298n::L298N_Driver;
use stdlib::pwm;
use stdlib::gpio;
use stdlib::Clock;
use stdlib::math;

// 1. Hardware definition (same as before).
hardware {
    // Left Motor Pins
    pwm M_Left_Speed at 9 [freq: 1000hz, resolution: 11];
    gpio M_Left_Dir1 at 2 [output];
    gpio M_Left_Dir2 at 3 [output];

    // Right Motor Pins
    pwm M_Right_Speed at 10 [freq: 1000hz, resolution: 11];
    gpio M_Right_Dir1 at 4 [output];
    gpio M_Right_Dir2 at 5 [output];
}

// 2. Global driver instances (same as before).
let mut motor_left: L298N_Driver;
let mut motor_right: L298N_Driver;

// 3. Global state variables for the ramp state machine.
// Instead of an enum, we use a single variable for the step direction.
let mut ramp_step: i16 = 1; // Start by ramping up
let mut current_speed: i16 = 0;

// 4. The main setup function.
fn main_setup() {
    // Instantiate drivers.
    motor_left = L298N_Driver(en: M_Left_Speed, in1: M_Left_Dir1, in2: M_Left_Dir2);
    motor_right = L298N_Driver(en: M_Right_Speed, in1: M_Right_Dir1, in2: M_Right_Dir2);
    
    // Configure the RampTask to run every 10 milliseconds, then start it.
    RampTask.setInterval(10);
    RampTask.start();
}

// 5. The non-blocking task, now with simplified state logic.
task RampTask {
    const MAX_RAMP_SPEED: i16 = 1023; // 50% speed

    // First, command the motors to the current speed.
    motor_left.set_speed(current_speed);
    motor_right.set_speed(current_speed);

    // Second, update the speed for the next run using the step variable.
    current_speed = current_speed + ramp_step;

    // Third, check the boundaries and flip the step direction if needed.
    if (ramp_step > 0 && current_speed >= MAX_RAMP_SPEED) {
        ramp_step = -1; // Reached the top, now ramp down.
    } else if (ramp_step < 0 && current_speed <= 0) {
        ramp_step = 1; // Reached the bottom, now ramp up.
    }
}
