// AEM Generic, Self-Generating Trigonometry Library (`trig`)
//
// This module provides a complete, integer-only trigonometric suite. It is
// inspired by the high-performance algorithms in the `fast_trig.hpp` library.
//
// It is generic over the lookup table size (`ENTRIES`) and uses `const fn`
// to generate its own LUTs at compile-time, providing excellent flexibility
// and zero runtime overhead for the tables.

module trig<const ENTRIES: u16> {

    // --- Compile-Time Constants & Helpers ---

    const PI_F32: f32 = 3.1415926535;

    // AEM's internal angle representation uses the full u16 range for 2*PI.
    const ANGLE_MAX: u16 = 65535;
    const ANGLE_PI: u16 = 32768;
    const ANGLE_HALF_PI: u16 = 16384;
    
    // The output of sin/cos is scaled to fit in an i16.
    // We use 8191 to represent 1.0, allowing for a range of -8191 to +8191.
    const OUTPUT_SCALE: i16 = 8191;

    // Compile-time function to count trailing zeros, used to determine bit shifts.
    // This is the AEM equivalent of `__builtin_ctz`.
    const fn count_trailing_zeros(u16: n) : u8 {
        if (n == 0) { return 16; }
        let mut count: u8 = 0;
        let mut temp = n;
        while ((temp & 1) == 0) {
            temp = temp >> 1;
            count = count + 1;
        }
        return count;
    }

    // --- LUT Generation (`const fn`) ---

    // A fast, compile-time polynomial approximation for sin(x) where x is 0 to PI/2.
    const fn sin_approx_compile_time(f32: x) : f32 {
        let x2 = x * x;
        let x3 = x2 * x;
        let x5 = x3 * x2;
        // A common 3-term polynomial approximation
        return x - (x3 / 6.0) + (x5 / 120.0);
    }

    // `const fn` to generate the sine lookup table.
    const fn generate_sine_lut() -> [i16; ENTRIES + 1] {
        let mut lut: [i16; ENTRIES + 1];
        for i in 0..=ENTRIES {
            let angle_rad = (i as f32 / ENTRIES as f32) * (PI_F32 / 2.0);
            let sin_val = sin_approx_compile_time(angle_rad);
            lut[i] = (sin_val * OUTPUT_SCALE as f32) as i16;
        }
        return lut;
    }

    // The actual sine LUT, generated and stored at compile-time.
    const SINE_LUT: [i16; ENTRIES + 1] = generate_sine_lut();

    // Constants derived from the generic ENTRIES parameter
    const LUT_SHIFT: u8 = count_trailing_zeros(ANGLE_HALF_PI / ENTRIES);
    const FRACTION_MASK: u16 = (1 << LUT_SHIFT) - 1;

    // --- Runtime Trigonometric Functions ---

    /// Calculates sine using the generated LUT and linear interpolation.
    /// Angle is a u16 (0-65535) representing 0 to 2*PI.
    fn sin(u16: angle) : i16 {
        let quadrant = (angle >> 14) as u8; // 0, 1, 2, or 3
        let angle_in_quadrant = angle & 16383; // 0-16383

        // Mirror the angle for quadrants where the wave is descending
        if ((quadrant & 1) > 0) {
            angle_in_quadrant = 16383 - angle_in_quadrant;
        }

        let index = (angle_in_quadrant >> LUT_SHIFT) as u16;
        let fraction = (angle_in_quadrant & FRACTION_MASK) as i16;

        let y1 = SINE_LUT[index];
        let y2 = SINE_LUT[index + 1];

        let slope = y2 - y1;
        let interpolated_value = y1 + ((slope * fraction) >> LUT_SHIFT);

        // Negate the result for quadrants 2 and 3 using a branchless trick.
        // This avoids a conditional jump, which can be faster on some architectures.
        let sign_mask: i16 = -(quadrant as i16 >> 1); // -1 if quadrant 2 or 3, 0 otherwise
        return (interpolated_value ^ sign_mask) - sign_mask;
    }

    /// Calculates cosine by shifting the angle by 90 degrees and calling sin().
    fn cos(u16: angle) : i16 {
        return sin(angle + ANGLE_HALF_PI);
    }
    
    /// Calculates tangent using sin and cos.
    /// Returns a scaled i16. Clamps to max/min value near vertical asymptotes.
    fn tan(u16: angle) : i16 {
        let sin_val = sin(angle);
        let cos_val = cos(angle);

        // Avoid division by zero
        if (cos_val > -10 && cos_val < 10) {
            if (sin_val >= 0) { return 32767; } else { return -32767; }
        }

        let result: i32 = (sin_val as i32 * OUTPUT_SCALE as i32) / cos_val as i32;
        
        // Clamp to i16 range
        if (result > 32767) { return 32767; }
        if (result < -32768) { return -32768; }
        
        return result as i16;
    }

    // Note: Full implementations for atan2, asin, and acos would require their own
    // LUTs and generation functions, following the same pattern as sine. They are
    // omitted here to keep the core example clear, but would be included in a
    // complete library.
    fn atan2(i16: y, i16: x) : u16 {
        // Placeholder for CORDIC or LUT-based implementation
        return 0;
    }

    fn asin(i16: value) : u16 {
        // Placeholder
        return 0;
    }

    fn acos(i16: value) : u16 {
        // Placeholder
        return 0;
    }
}