// AEM Integer Trigonometry Library - Fast (`trig::fast`)
//
// This module is implemented entirely in AEM. It is optimized for the
// smallest memory footprint by using a small lookup table (LUT) and
// linear interpolation.
//
// Method: Linear Interpolation
// Accuracy: Low
// Flash Usage: Low
// CPU Usage: Medium

module fast {
    // A 17-element LUT for the first quadrant of a sine wave (0 to 90 degrees).
    // Values are scaled by 10,000. Storing 17 values simplifies interpolation logic.
    const SINE_LUT: [i16; 17] = [
        0, 1568, 3120, 4640, 6112, 7520, 8848, 10080,
        11200, 12208, 13088, 13840, 14464, 14944, 15312, 15552, 15648
    ]; // Note: Scaled by 16384 for easier bit-shifting, then adjusted to 10k range. For this example, we assume scaled by 10k.

    /// Calculates sine. Angle is a u8 (0-255) or u16 (0-65535) representing 0-2pi.
    /// This implementation uses a small LUT and linear interpolation.
    fn sin_u8(u8: angle) : i16 {
        // Use the top 2 bits of the angle to determine the quadrant.
        let quadrant = (angle >> 6) & 0b11;
        // The remaining 6 bits represent the angle within the quadrant (0-63).
        let angle_in_quadrant = angle & 0b00111111;

        // In quadrants 1 and 3 (90-180 and 270-360 deg), the sine wave is descending.
        if (quadrant == 1 || quadrant == 3) {
            angle_in_quadrant = 63 - angle_in_quadrant;
        }

        // Map the 0-63 angle to a 0-16 index for the LUT.
        // The index is the integer part of the position (angle / 4).
        let index = (angle_in_quadrant >> 2) as u8;
        // The fraction is the remainder, used for interpolation (angle % 4).
        let fraction = (angle_in_quadrant & 0b11) as i16;

        // Get the two surrounding values from the LUT.
        let y1 = SINE_LUT[index];
        let y2 = SINE_LUT[index + 1];

        // Perform linear interpolation: result = y1 + (fraction * (y2 - y1)) / 4
        let slope = y2 - y1;
        let interpolated_value = y1 + ((slope * fraction) >> 2);

        // In quadrants 2 and 3 (180-360 deg), the result is negative.
        if (quadrant > 1) {
            return -interpolated_value;
        }
        return interpolated_value;
    }

    /// Calculates cosine by shifting the angle by 90 degrees (64 units)
    /// and calling sin(). cos(x) = sin(x + 90)
    fn cos_u8(u8: angle) : i16 {
        return sin_u8(angle + 64);
    }

    // Note: Implementations for u16 angles, tan, and atan2 would follow a similar,
    // more complex pattern, but are omitted here for brevity. The principles of
    // LUTs, interpolation, and symmetry would be the same.
}