// AEM Integer Trigonometry Library - Balanced (`trig::balanced`)
//
// This module is implemented entirely in AEM. It provides a balance
// between accuracy and memory usage by using a medium-sized lookup table (LUT)
// and linear interpolation.
//
// Method: Linear Interpolation
// Accuracy: Medium
// Flash Usage: Medium
// CPU Usage: Low

module balanced {
    // A 33-element LUT for the first quadrant of a sine wave (0 to 90 degrees).
    // Values are scaled by 10,000.
    const SINE_LUT: [i16; 33] = [
        0, 784, 1568, 2344, 3120, 3880, 4624, 5352,
        6064, 6752, 7416, 8048, 8648, 9216, 9744, 10240,
        10696, 11120, 11504, 11856, 12176, 12464, 12720, 12944,
        13136, 13296, 13424, 13520, 13584, 13616, 13616, 13584, 13520
    ];

    fn sin_u8(u8: angle) : i16 {
        let quadrant = (angle >> 6) & 0b11;
        let angle_in_quadrant = angle & 0b00111111; // 0-63

        if (quadrant == 1 || quadrant == 3) {
            angle_in_quadrant = 63 - angle_in_quadrant;
        }

        // Map the 0-63 angle to a 0-32 index for the LUT.
        // The index is the integer part of the position (angle / 2).
        let index = (angle_in_quadrant >> 1) as u8;
        // The fraction is the remainder for interpolation (angle % 2).
        let fraction = (angle_in_quadrant & 0b1) as i16;

        let y1 = SINE_LUT[index];
        let y2 = SINE_LUT[index + 1];

        // Perform linear interpolation: result = y1 + (fraction * (y2 - y1)) / 2
        let slope = y2 - y1;
        let interpolated_value = y1 + ((slope * fraction) >> 1);

        if (quadrant > 1) {
            return -interpolated_value;
        }
        return interpolated_value;
    }

    fn cos_u8(u8: angle) : i16 {
        return sin_u8(angle + 64);
    }
}